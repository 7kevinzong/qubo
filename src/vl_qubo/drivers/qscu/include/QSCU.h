#ifndef QSCU_H
#define QSCU_H

/*
 * Endpoint.h
 * Header file for QuboBus Endpoint.
 *
 * Copyright (C) 2016 Robotics at Maryland
 * Copyright (C) 2016 Greg Harris <gharris1727@gmail.com>
 * All rights reserved.
 */

// memcpy method
#include <string>
// std::string type
#include <string.h>
// Unix includes
#include <unistd.h>
// Error handling
#include <stdexcept>
// uint*_t types
#include <stdint.h>
// vector type
#include <vector>
// speed_t type
#include <termios.h>
// shared_ptr type
#include <memory>

// Qubobus protocol definitions
#include "qubobus.h"
#include "io.h"
/* * Exception class for errors generated by the QSCU
 */

class QSCUException : public std::runtime_error
{
    public:
        QSCUException(std::string message)
            : runtime_error(message) {}
};

/**
 * QSCU API class
 * Contains all the low-level I/O abstraction, and allows the user to communicate
 * with the QSCU hardware at a high level. Connects to a unix serial/usb terminal
 * and speaks over Qubobus protocol to send and recieve packets of data.
 */
class QSCU
{
    public:
        /**
         * Constructor for a new DVL interface.
         * @param (std::string) unix device name
         * @param (QSCUSpeed) Baudrate to use for connection.
         */
        QSCU(std::string deviceFile, speed_t baud);
        /** Destructor that cleans up and closes the device. */
        ~QSCU();
        /** 
         * Opens the device and configures the I/O terminal. 
         * Requires dialout permissions to the device in _deviceFile.
         */
        void openDevice();
        /** 
         * Checks if the QSCU is currently open and avaiable 
         * @return (bool) whether the DVL is avaliable for other API operations.
         */
        bool isOpen();
        /** Ensures that the QSCU is open, throws an exception otherwise. */
        void assertOpen();
        /** Disconnectes from the device and closes the teriminal. */
        void closeDevice();
    private: // Internal functionality.
        /** Unix file name to connect to */
        std::string _deviceFile;
        /** Data rate to communicate with */
        speed_t _termBaud;
        /** Serial port for serial I/O */
        int _deviceFD;
        /** Timeout (sec,usec) on read/write */
        struct timeval _timeout;
        /** State of the protocol link. */
        IO_State _state;

        /** Read bytes to a blob, return the bytes not read. */
        ssize_t readRaw(void*, void* blob, size_t bytes_to_read);
        /** Write bytes from a blob, return the bytes not written. */
        ssize_t writeRaw(void*, void* blob, size_t bytes_to_write);
        
        /** Write a command with variable args and read something back */
        void sendMessage(Transaction *transaction, void *payload, void *response);

         
        ssize_t serial_read(void *io_host, void *buffer, size_t size); 
        
        ssize_t serial_write(void *io_host, void *buffer, size_t size); 

};


 
ssize_t serial_read(void *io_host, void *buffer, size_t size); 

ssize_t serial_write(void *io_host, void *buffer, size_t size);/


#endif
